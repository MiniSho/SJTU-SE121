# 报告文档

### Part 1

(1)

| 硬币\金额 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |  11  |  12  |  13  |
| :-------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|     0     |  1   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |
|     1     |  1   |  1   |  1   |  1   |  1   |  1   |  1   |  1   |  1   |  1   |  1   |  1   |  1   |  1   |
|     2     |  1   |  1   |  2   |  2   |  3   |  3   |  4   |  4   |  5   |  5   |  6   |  6   |  7   |  7   |
|     5     |  1   |  1   |  2   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  10  |  11  |  13  |  14  |
|    10     |  1   |  1   |  2   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  11  |  12  |  15  |  16  |

（2）这个动态规划的时间复杂度是多少？

答：O( NM )

（3) 请将这个动态规划的空间复杂度优化到O(M)，并指出你是如何优化的

答：在计算$dp[j][i]$时，只需要第$j-1$、$j$的数据，所以只需要两个长度为$i$的数组即可，此时空间复杂度就可以降到$O(M)$ 



思路：

​	本题影响硬币组合数的关键是在于硬币的种类。最特殊的情况便是没有硬币和只有1种面额的硬币。当提供两种面额以上的硬币时，组合数就开始发生变化，假设原有i种面额的硬币，新增一个面额为k的硬币，对于金额j，变化的可能性为：

1. 不用新的面额硬币则有$dp[i][j]$种组合
2. 使用新面额硬币，则至少使用一枚新面额硬币，则剩余金额j-k为可组合金额，而使用包括k在内的面额硬币组合j-k元金额的组合数在计算本次结果之前已经得到，即为$dp[i+1][j-k]$



代码实现：

核心代码

建立$2\times amount$的数组用于记录组合数

特判：当金额小于新面额时，组合数不变，否则满足$dp[i][j] = dp[i-1][j] + dp[i][j-coins[line]]$的状态转移方程

```c++
    while (line < size) {
        for (int i = 0; i < amount + 1; i++) {//金额
            if (j == 1) {
                 //特判 当金额小于新面额时，则组合数不变
                if (i < coins[line]) {
                    dp[1][i] = dp[0][i];
                } else {
                    dp[1][i] = dp[0][i] + dp[1][i - coins[line]];
                }
            }
            if (j == 0) {
                if (i < coins[line]) {
                    dp[0][i] = dp[1][i];
                } else {
                    dp[0][i] = dp[1][i] + dp[0][i - coins[line]];
                }
            }
        }
        line++;
        j++;
        j %= 2;
    }
```



### Part 2

1. 倒霉蛋：B

   决斗过程:

   A吃鸡：$E\rarr F,D \rarr C,A\rarr B, A\rarr D, A\rarr E$

   C吃鸡：$E\rarr D, E\rarr F, C \rarr F, C\rarr B, C\rarr A$

   D吃鸡：$C\rarr B, C\rarr A, E\rarr F, C\rarr E, D\rarr C$

   E吃鸡：$C \rarr B, C \rarr A, D\rarr C, F\rarr C, E\rarr F$

   F吃鸡：$E\rarr D, C \rarr E, C\rarr B, C\rarr A, F\rarr C$

   

2. 时间复杂度：$O(n^3)$

   空间复杂度：$O(n^2)$

   时间复杂度已达到最佳
   
   状态转移方程：
   $$
   dp[i][j] = \begin{cases}
   1&  if~\exist ~dp[i][k]~\text{&&}~dp[k][j]~\text{&&}~(conquer[i][k] || conquer[j][k])  \\
   0& \text{else}
   \end{cases}
   $$
   
   
   
   思路：
   
   ​		用bool类型的二维数组矩阵$dp[amount][amount]$来记录两人是否能相遇决斗，$dp[i][j]$=true表示 i 能与 j 相遇决斗(这并不表示 j 能与 i 相遇决斗，i和j的顺序不能颠倒)。所以dp的初始化为$dp[i][i+1]$ = true，其余均为false。
   
   ​		我们对每个人同时进行判断，即第 i 个人能否对旁边距离自己（0,1,2...,amount-1）的人决斗,之后再判断第i+1个人，能否决斗的判断由第三层循环完成。对于i能否与j决斗，选择中间人k，当这个中间人k满足第i个人能和k决斗，k能和j决斗，并且i或j能打败k时，i和j能相遇决斗。
   
   
   
   代码实现：
   
   核心代码如下，代码过程如同思路讲述的一致：
   
   ```c++
   for (int i = 2; i <= amount; i++) {
   	for (int end, start = 0; start != amount; start++) {
   		end = (i + start) % amount;
   		if (dp[start][end])continue;
   
   		for (int k = (start + 1) % amount; k != end; k = (k + 1) % amount) {
   			if (dp[start][k] && dp[k][end] && (conquer[start][k] || conquer[end][k])) {
   				dp[start][end] = true;
   			break;
               }
           }
       }
   }
   ```
   
   

### Part 3

1. 写出这个算法的状态转移方程

   由于走到n点就停止，所以走到n点的概率就是每个在n点的状态的期望和

   状态转移方程：$f[i][u] = \Sigma \frac{f[i+damage[u]][j]}{degree[j]}$

2. 
$$
\begin{cases}
   1 \cdot f(2,1) - \frac{1}{3}\cdot f(2,2) + 0\cdot f(5,2) = \frac{1}{4}f(2,3) \\
   -\frac{1}{2} f(2,1) + f(2,2)+ 0 \cdot f(5,2) = \frac{1}{4} f(2,3) + \frac{1}{3} f(2,4)\\
   0\cdot f(2,1) + 0\cdot f(2,2) + f(5,2) = \frac{1}{4} f(2,3)+\frac{1}{3}f(2,4) 
   \end{cases}
$$

​	未知数是 $f(hp,i), 当damage[i]=0$

​	系数：


$$
f(hp,i)前的系数为 ~1\\
f(hp,i),damage[j]=0前的系数为\begin{cases}
-\frac{1}{|E(k)|},~~(k,i)\in E\\
0,~~ 0.W
\end{cases}\\
常数项为 \frac{1}{|E(k)|} f(hp,i),damage[j] > 0~\text{&&}~  (j,i)\in E\\
增广矩阵： \left[
 \begin{matrix}
   1 & -\frac{1}{3} & 0 & \frac{1}{4}f(2,3) \\
   -\frac{1}{2} & 1 & 0 & \frac{1}{4}f(2,3)+ \frac{1}{3}f(2,4) \\
   0 & 0 & 1 & \frac{1}{4}f(2,3)+\frac{1}{3}f(2,4)
  \end{matrix}
  \right]\\
  f(2,3) = \frac{1}{5}\cdot \frac{1}{2} + \frac{9}{40}\cdot\frac{1}{3}\\
  f(2,4) = \frac{1}{2}\cdot \frac{1}{3}
$$

3. 时间复杂度：$O(n^2hp + n^3)$

   空间复杂度：$O(n^2)$

   每一层消元一次，那么最终复杂度为$O(n^3hp)$,太高。

   可以发现，每一次的消元时的系数矩阵是一样的，有区别的只是常数项，所以根据$Ax = b \rarr x = A^{-1}b$ ，求出逆矩阵后乘向量即可。一次的复杂度为$O(N^2)$ ,最后时间复杂度可以降至$O(n^2hp + n^3)$
   
   
   
   思路：
   
   ​	设$f[i][j]$表示为剩余 i 点血量，走到点 j 的期望次数，状态转移方程如第一小问所示，
   $$
   f[i][u] = \Sigma \frac{f[i+damage[u]][j]}{degree[j]}
   $$
   ​	用血量作为转移的阶段来计算dp表，以每层的每个顶点的状态方程联立，形成N个线性方程，其中，$dp[i][j]$为变量；分为两种情况，1.当该点有伤害时，即damage[i] > 0，直接转移，因为方程右侧的$dp[i+damage[u][j]$在之前的层中已计算得到 2.当该点无伤害时，出现了环，此时用高斯消元解。每一层递推，最后得出求和$f[i][n](i = 1,2...,hp)$即为答案
   
   
   
   代码实现：
   
   首先 初始化所有变量，由于有多组测试数据，貌似不手动初始化为0，数组内有一些乱七八糟的数据
   
   ```c++
       // 数据初始化 --begin
       for (int i = 0; i <= hp; i++) {
           f[i] = new double[n + 1];
           for (int j = 0; j <= n; j++) {
               f[i][j] = 0;
           }
       }
       for (int i = 0; i <= n; i++) {
           K[i] = new double[n + 1];
           fir[i] = -1;
   
           for (int j = 0; j <= n; j++) {
               K[i][j] = 0;
           }
   
           degree[i] = 0;
           t[i] = 0;
       }
       // 数据初始化 --end
   ```
   
   该阶段中 son[total]和next[total]一起构成一个邻接表(假设为命名为e)，
   
   index[x]记录顶点x的邻接表的加入的这一条边在e中的索引
   
   next[total]记录的是顶点x的邻接表下一条边的索引
   
   son[total]记录的是该边的终点y
   
   ```c++
   for (int i = 0; i < int(edges.size()); i += 2) {
   	add(edges[i], edges[i + 1], son, next, index, total);
   	add(edges[i + 1], edges[i], son, next, index, total);
       degree[edges[i]]++;
       degree[edges[i + 1]]++;
	}
       
   void add(int x, int y, int *son, int *next, int *index, int&total) {
    	son[total] = y;
    	next[total] = index[x];
    	index[x] = total++;
      }
   ```
   
   计算方程组中各个项的系数
   
   $K[i][j]$表示第i行第j个顶点的系数
   
   并完成矩阵的inverse
   
   ```c++
   for (int i = 1; i <= n; i++) {
           K[i][i] = 1.0;
           if (!damage[i - 1]) {
               for (int j = index[i]; j != -1; j = next[j]) {
                   if (son[j] != n) {
                       K[i][son[j]] -= 1.0 / degree[son[j]];
                   }
               }
           }
       }
   for (int i = 1; i <= n; i++) {
           for (int j = 1; j <= n; j++) {
               if (i != j && fabs(bool(K[j][i]))) {
                   total++;
                   g[total].x = i;
                   g[total].y = j;
                   g[total].s = K[j][i] / K[i][i];
                   for (int k = 1; k <= n; k++) {
                       K[j][k] -= g[total].s * K[i][k];
                   }
               }
           }
       }
   ```
   
   根据式子$x = A^{-1}b$用$O(N^2)$的时间计算$A^{-1}b$
   
   数组$t$表示常数矩阵b，最后 $f[i][j] = t[j]/K[j][j]$ 得到 hp—n的表
   
   第一层循环 用于计算每一层的概率
   
   第二第三层循环 根据状态转移方程计算常数矩阵数组t
   
   ```c++
       for (int i = hp; i > 0; i--) {
           //t初始化 
           for (int m = 0; m <= n; m++) {
               t[m] = 0;
           }
           if (i == hp) {
               t[1] = 1.0;
           }
           for (int j = 1; j <= n; j++) {
               for (int k = index[j]; k != -1; k = next[k]) {
                   if (son[k] != n && damage[j - 1] && (i + damage[j - 1] <= hp)) {
                       t[j] += f[i + damage[j - 1]][son[k]] / (double) degree[son[k]];
                   }
               }
   
           }
           for (int j = 1; j <= total; j++) {
               t[g[j].y] -= t[g[j].x] * g[j].s;
           }
           for (int j = 1; j <= n; j++) {
               f[i][j] = t[j] / K[j][j];
           }
       }
   ```
   
   
